{"meta":{"title":"tqzer's blog","subtitle":"tqzer","description":"tqzer's blog","author":null,"url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"最短路径","date":"2020-01-20T05:21:44.054Z","path":"2020/01/20/最短路径/","text":"title: 最短路径date: 2020-01-20 13:21:43tags:图论— 原理：1.从起点到终点的最短路径最多经过n-1条边（没有负环） 2.已经确定最短路径的两点中任意一段都是最短路径 1. bellman_ford算法 O(n*e) 从起点开始，用已经更新过的点所连的边去更新其他的点，最多更新n-1次可以把所有点更新完。 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;long long n,m,s,d[10010],g[5010][5010];int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=1;i&lt;=n;i++) d[i]=2147483647;//初始化除了起点设为无穷大 d[s]=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) g[i][j]=2147483647; for(int i=1;i&lt;=m;i++)&#123; int f,e,w; cin&gt;&gt;f&gt;&gt;e&gt;&gt;w; if(w&lt;g[f][e])g[f][e]=w;//防止有重边的数据 &#125; bool flag=true;//flag表示此次循环有没有更新节点，若没有更新说明更新完，跳出循环 for(int i=1;flag&amp;&amp;i&lt;=n;i++)&#123; flag=false; for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++)&#123;//枚举所有的边，用已更新的节点去更新其他节点 if(d[j]+g[j][k]&lt;d[k])&#123;//松弛 d[k]=d[j]+g[j][k]; flag=true; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) cout&lt;&lt;d[i]&lt;&lt;' '; cout&lt;&lt;endl; return 0;&#125; 2.SPFA算法此算法实质是bellman_ford算法的队列优化。以上的算法做了许多无用的枚举，因为一个节点被更新，只有与它相连的点才可能被更新。与宽搜的区别：宽搜一般不会重复入队，SPFA会重复入队，即标记需要恢复。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,s,d[10010],vh[10010],que[1000010];struct node&#123; int e,w;&#125;;vector &lt;node&gt; g[10010];int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=1;i&lt;=n;i++) d[i]=2147483647; d[s]=0; for(int i=1;i&lt;=m;i++)&#123; int f,e,w; cin&gt;&gt;f&gt;&gt;e&gt;&gt;w; node q; q.e=e; q.w=w; g[f].push_back(q); &#125; int head=1,tail=2; que[1]=s; while(head&lt;tail)&#123; int x=que[head],t=g[x].size(); for(int i=0;i&lt;t;i++)&#123; if(d[x]&lt;d[g[x][i].e]-g[x][i].w)&#123;//因为相加会超int所以改成减 d[g[x][i].e]=d[x]+g[x][i].w; if(!vh[g[x][i].e])&#123;//如果不在队中就入队 que[tail]=g[x][i].e;//将更新后的节点入队 tail++; vh[g[x][i].e]=1; &#125; &#125; &#125; head++; vh[x]=0;//因为找到的不一定是最短路径，所以要重复入队 &#125; for(int i=1;i&lt;=n;i++) cout&lt;&lt;d[i]&lt;&lt;' '; cout&lt;&lt;endl; return 0;&#125; 3.1 Dijkstra算法：O(n^2)实现过程：1.找到未确定最短路径的点中目前距离最小的点，可以确定这个点的最短路径就是这个距离。2.标记这个点，并用这个点去扩展其他点的最短路径。 但为什么步骤一是正确的呢？ 因为找到的这个点的距离是由所有确定最短路径的点扩展而来的，如果它不是最短路径，那这个最短路径一定是由未确定的点扩展而来的，但其他的点只能绕一圈扩展到这个点，一定比当前距离长，由此得证。 以上思想是此算法的灵魂，在最短路径的变式中，必须满足以上的贪心法则，才可以运用此算法。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,s,d[10010],vh[10010];struct node&#123; int e,w;&#125;;vector &lt;node&gt; g[10010];//用vector实现，防止爆空间int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=1;i&lt;=n;i++) d[i]=2147483647; d[s]=0; for(int i=1;i&lt;=m;i++)&#123; int f,e,w; cin&gt;&gt;f&gt;&gt;e&gt;&gt;w; node q; q.e=e; q.w=w; g[f].push_back(q); &#125; for(int i=1;i&lt;=n;i++)&#123; int minn=1e9,minid=0; for(int j=1;j&lt;=n;j++)&#123;//找没有被标记的点的最小值 if(!vh[j]&amp;&amp;d[j]&lt;minn)&#123; minn=d[j]; minid=j; &#125; &#125; vh[minid]=1;//此点确定最短路径 int t=g[minid].size(); for(int j=0;j&lt;t;j++)&#123; if(!vh[g[minid][j].e]&amp;&amp;d[minid]&lt;d[g[minid][j].e]-g[minid][j].w) d[g[minid][j].e]=d[minid]+g[minid][j].w; &#125; &#125; for(int i=1;i&lt;=n;i++) cout&lt;&lt;d[i]&lt;&lt;' '; cout&lt;&lt;endl; return 0;&#125; 3.2 Dijkstra算法的优先队列优化:O((n+m)*log m)由于以上算法每次都要找最小值，顺序查找复杂度为O(n^2)，所以可以用堆优化为O（nlogn）这里用stl中的优先队列实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,s,d[100010],vh[100010];struct node&#123; int e,w;&#125;;struct node2&#123; int id,dis;&#125;;bool operator&lt; (node2 a,node2 b)&#123; return a.dis&gt;b.dis;//由于不清楚运算符重载在优先队列里的操作，符号一开始写反了&#125;vector &lt;node&gt; g[100010];priority_queue &lt;node2&gt; que;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=1;i&lt;=n;i++) d[i]=2147483647; d[s]=0; for(int i=1;i&lt;=m;i++)&#123; int f,e,w; cin&gt;&gt;f&gt;&gt;e&gt;&gt;w; node q; q.e=e; q.w=w; g[f].push_back(q); &#125; node2 q; q.dis=0; q.id=s; que.push(q); for(int i=1;i&lt;=n;i++)&#123; while(vh[que.top().id])que.pop(); int head=que.top().id; vh[head]=1; que.pop(); int t=g[head].size(); for(int j=0;j&lt;t;j++)&#123; if(!vh[g[head][j].e]&amp;&amp;d[head]&lt;d[g[head][j].e]-g[head][j].w)&#123; d[g[head][j].e]=d[head]+g[head][j].w; q.id=g[head][j].e;//入栈的id为这条边的终点序号，不是循环序号 q.dis=d[g[head][j].e]; que.push(q); &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) cout&lt;&lt;d[i]&lt;&lt;' '; cout&lt;&lt;endl; return 0;&#125; 4.Floyed算法：O(n^3)此算法是基于dp思想的。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define INF 2147483647using namespace std;long long n,m,s,d[1010][1010];int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; if(i!=j)d[i][j]=INF; &#125; for(int i=1;i&lt;=m;i++)&#123; int f,e,w; cin&gt;&gt;f&gt;&gt;e&gt;&gt;w; if(d[f][e]&gt;w)d[f][e]=w; &#125; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); for(int i=1;i&lt;=n;i++) cout&lt;&lt;d[s][i]&lt;&lt;' '; cout&lt;&lt;endl; return 0;&#125; 它还可以判断连通性，如下： 1234for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) g[i][j]=g[i][j]||(g[i][k]&amp;&amp;g[k][j]);","raw":"---\ntitle: 最短路径\ndate: 2020-01-20 13:21:43\ntags:\n图论---\n\n## 原理：\n1.从起点到终点的最短路径最多经过n-1条边（没有负环）\n\n2.已经确定最短路径的两点中任意一段都是最短路径\n\n## 1. bellman_ford算法 O(n*e)\n 从起点开始，用已经更新过的点所连的边去更新其他的点，最多更新n-1次可以把所有点更新完。\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nlong long n,m,s,d[10010],g[5010][5010];\nint main(){\n\tcin>>n>>m>>s;\n\tfor(int i=1;i<=n;i++)\n\t\td[i]=2147483647;//初始化除了起点设为无穷大\n\td[s]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tg[i][j]=2147483647;\n\tfor(int i=1;i<=m;i++){\n\t\tint f,e,w;\n\t\tcin>>f>>e>>w;\n\t\tif(w<g[f][e])g[f][e]=w;//防止有重边的数据\n\t}\n\tbool flag=true;//flag表示此次循环有没有更新节点，若没有更新说明更新完，跳出循环\n\tfor(int i=1;flag&&i<=n;i++){\n\t\tflag=false;\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tfor(int k=1;k<=n;k++){//枚举所有的边，用已更新的节点去更新其他节点\n\t\t\t\tif(d[j]+g[j][k]<d[k]){//松弛\n\t\t\t\t\td[k]=d[j]+g[j][k];\n\t\t\t\t\tflag=true;\n\t\t\t\t}\n\t\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tcout<<d[i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n```\n## 2.SPFA算法\n此算法实质是bellman_ford算法的队列优化。\n以上的算法做了许多无用的枚举，因为一个节点被更新，只有与它相连的点才可能被更新。\n与宽搜的区别：宽搜一般不会重复入队，SPFA会重复入队，即标记需要恢复。\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,s,d[10010],vh[10010],que[1000010];\nstruct node{\n\tint e,w;\n};\nvector <node> g[10010];\nint main(){\n\tcin>>n>>m>>s;\n\tfor(int i=1;i<=n;i++)\n\t\td[i]=2147483647;\n\td[s]=0;\n\tfor(int i=1;i<=m;i++){\n\t\tint f,e,w;\n\t\tcin>>f>>e>>w;\n\t\tnode q;\n\t\tq.e=e;\n\t\tq.w=w;\n\t\tg[f].push_back(q);\n\t}\n\tint head=1,tail=2;\n\tque[1]=s;\n\twhile(head<tail){\n\t\tint x=que[head],t=g[x].size();\n\t\tfor(int i=0;i<t;i++){\n\t\t\tif(d[x]<d[g[x][i].e]-g[x][i].w){//因为相加会超int所以改成减\n\t\t\t\td[g[x][i].e]=d[x]+g[x][i].w;\n\t\t\t\tif(!vh[g[x][i].e]){//如果不在队中就入队\n\t\t\t\t\tque[tail]=g[x][i].e;//将更新后的节点入队\n\t\t\t\t\ttail++;\n\t\t\t\t\tvh[g[x][i].e]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\thead++;\n\t\tvh[x]=0;//因为找到的不一定是最短路径，所以要重复入队\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tcout<<d[i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n```\n## 3.1 Dijkstra算法：O(n^2)\n实现过程：1.找到未确定最短路径的点中目前距离最小的点，可以确定这个点的最短路径就是这个距离。\n2.标记这个点，并用这个点去扩展其他点的最短路径。\n\n但为什么步骤一是正确的呢？\n\n因为找到的这个点的距离是由所有确定最短路径的点扩展而来的，如果它不是最短路径，那这个最短路径一定是由未确定的点扩展而来的，但其他的点只能绕一圈扩展到这个点，一定比当前距离长，由此得证。\n\n以上思想是此算法的灵魂，在最短路径的变式中，必须满足以上的贪心法则，才可以运用此算法。\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,s,d[10010],vh[10010];\nstruct node{\n\tint e,w;\n};\nvector <node> g[10010];//用vector实现，防止爆空间\nint main(){\n\tcin>>n>>m>>s;\n\tfor(int i=1;i<=n;i++)\n\t\td[i]=2147483647;\n\td[s]=0;\n\tfor(int i=1;i<=m;i++){\n\t\tint f,e,w;\n\t\tcin>>f>>e>>w;\n\t\tnode q;\n\t\tq.e=e;\n\t\tq.w=w;\n\t\tg[f].push_back(q);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint minn=1e9,minid=0;\n\t\tfor(int j=1;j<=n;j++){//找没有被标记的点的最小值\n\t\t\tif(!vh[j]&&d[j]<minn){\n\t\t\t\tminn=d[j];\n\t\t\t\tminid=j;\n\t\t\t}\n\t\t}\n\t\tvh[minid]=1;//此点确定最短路径\n\t\tint t=g[minid].size();\n\t\tfor(int j=0;j<t;j++){\n\t\t\tif(!vh[g[minid][j].e]&&d[minid]<d[g[minid][j].e]-g[minid][j].w)\n\t\t\t\td[g[minid][j].e]=d[minid]+g[minid][j].w;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tcout<<d[i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n\n```\n## 3.2 Dijkstra算法的优先队列优化:O((n+m)*log m)\n由于以上算法每次都要找最小值，顺序查找复杂度为O(n^2)，所以可以用堆优化为O（nlogn）\n这里用stl中的优先队列实现\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,s,d[100010],vh[100010];\nstruct node{\n\tint e,w;\n};\nstruct node2{\n\tint id,dis;\n};\nbool operator< (node2 a,node2 b){\n\treturn a.dis>b.dis;//由于不清楚运算符重载在优先队列里的操作，符号一开始写反了\n}\nvector <node> g[100010];\npriority_queue <node2> que;\nint main(){\n\tcin>>n>>m>>s;\n\tfor(int i=1;i<=n;i++)\n\t\td[i]=2147483647;\n\td[s]=0;\n\tfor(int i=1;i<=m;i++){\n\t\tint f,e,w;\n\t\tcin>>f>>e>>w;\n\t\tnode q;\n\t\tq.e=e;\n\t\tq.w=w;\n\t\tg[f].push_back(q);\n\t}\n\tnode2 q;\n\tq.dis=0;\n\tq.id=s;\n\tque.push(q);\n\tfor(int i=1;i<=n;i++){\n\t\twhile(vh[que.top().id])que.pop();\n\t\tint head=que.top().id;\n\t\tvh[head]=1;\n\t\tque.pop();\n\t\tint t=g[head].size();\n\t\tfor(int j=0;j<t;j++){\n\t\t\tif(!vh[g[head][j].e]&&d[head]<d[g[head][j].e]-g[head][j].w){\n\t\t\t\td[g[head][j].e]=d[head]+g[head][j].w;\n\t\t\t\tq.id=g[head][j].e;//入栈的id为这条边的终点序号，不是循环序号\n\t\t\t\tq.dis=d[g[head][j].e];\n\t\t\t\tque.push(q);\n\t\t\t}\t\t\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tcout<<d[i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n```\n## 4.Floyed算法：O(n^3)\n此算法是基于dp思想的。\n```cpp\n#include<bits/stdc++.h>\n#define INF 2147483647\nusing namespace std;\nlong long n,m,s,d[1010][1010];\nint main(){\n\tcin>>n>>m>>s;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i!=j)d[i][j]=INF;\n\t\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint f,e,w;\n\t\tcin>>f>>e>>w;\n\t\tif(d[f][e]>w)d[f][e]=w;\n\t}\n\tfor(int k=1;k<=n;k++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\tfor(int i=1;i<=n;i++)\n\t\tcout<<d[s][i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n```\n它还可以判断连通性，如下：\n```cpp\nfor(int k=1;k<=n;k++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tg[i][j]=g[i][j]||(g[i][k]&&g[k][j]);\n```\n","content":"<hr>\n<p>title: 最短路径<br>date: 2020-01-20 13:21:43<br>tags:<br>图论—</p>\n<h2 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h2><p>1.从起点到终点的最短路径最多经过n-1条边（没有负环）</p>\n<p>2.已经确定最短路径的两点中任意一段都是最短路径</p>\n<h2 id=\"1-bellman-ford算法-O-n-e\"><a href=\"#1-bellman-ford算法-O-n-e\" class=\"headerlink\" title=\"1. bellman_ford算法 O(n*e)\"></a>1. bellman_ford算法 O(n*e)</h2><p> 从起点开始，用已经更新过的点所连的边去更新其他的点，最多更新n-1次可以把所有点更新完。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n,m,s,d[<span class=\"number\">10010</span>],g[<span class=\"number\">5010</span>][<span class=\"number\">5010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\td[i]=<span class=\"number\">2147483647</span>;<span class=\"comment\">//初始化除了起点设为无穷大</span></span><br><span class=\"line\">\td[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">\t\t\tg[i][j]=<span class=\"number\">2147483647</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> f,e,w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span>&gt;&gt;f&gt;&gt;e&gt;&gt;w;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(w&lt;g[f][e])g[f][e]=w;<span class=\"comment\">//防止有重边的数据</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> flag=<span class=\"literal\">true</span>;<span class=\"comment\">//flag表示此次循环有没有更新节点，若没有更新说明更新完，跳出循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;flag&amp;&amp;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tflag=<span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">1</span>;k&lt;=n;k++)&#123;<span class=\"comment\">//枚举所有的边，用已更新的节点去更新其他节点</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(d[j]+g[j][k]&lt;d[k])&#123;<span class=\"comment\">//松弛</span></span><br><span class=\"line\">\t\t\t\t\td[k]=d[j]+g[j][k];</span><br><span class=\"line\">\t\t\t\t\tflag=<span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;d[i]&lt;&lt;<span class=\"string\">' '</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-SPFA算法\"><a href=\"#2-SPFA算法\" class=\"headerlink\" title=\"2.SPFA算法\"></a>2.SPFA算法</h2><p>此算法实质是bellman_ford算法的队列优化。<br>以上的算法做了许多无用的枚举，因为一个节点被更新，只有与它相连的点才可能被更新。<br>与宽搜的区别：宽搜一般不会重复入队，SPFA会重复入队，即标记需要恢复。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,d[<span class=\"number\">10010</span>],vh[<span class=\"number\">10010</span>],que[<span class=\"number\">1000010</span>];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> e,w;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt;node&gt; g[<span class=\"number\">10010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\td[i]=<span class=\"number\">2147483647</span>;</span><br><span class=\"line\">\td[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> f,e,w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span>&gt;&gt;f&gt;&gt;e&gt;&gt;w;</span><br><span class=\"line\">\t\tnode q;</span><br><span class=\"line\">\t\tq.e=e;</span><br><span class=\"line\">\t\tq.w=w;</span><br><span class=\"line\">\t\tg[f].push_back(q);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> head=<span class=\"number\">1</span>,tail=<span class=\"number\">2</span>;</span><br><span class=\"line\">\tque[<span class=\"number\">1</span>]=s;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(head&lt;tail)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x=que[head],t=g[x].size();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;t;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(d[x]&lt;d[g[x][i].e]-g[x][i].w)&#123;<span class=\"comment\">//因为相加会超int所以改成减</span></span><br><span class=\"line\">\t\t\t\td[g[x][i].e]=d[x]+g[x][i].w;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(!vh[g[x][i].e])&#123;<span class=\"comment\">//如果不在队中就入队</span></span><br><span class=\"line\">\t\t\t\t\tque[tail]=g[x][i].e;<span class=\"comment\">//将更新后的节点入队</span></span><br><span class=\"line\">\t\t\t\t\ttail++;</span><br><span class=\"line\">\t\t\t\t\tvh[g[x][i].e]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\thead++;</span><br><span class=\"line\">\t\tvh[x]=<span class=\"number\">0</span>;<span class=\"comment\">//因为找到的不一定是最短路径，所以要重复入队</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;d[i]&lt;&lt;<span class=\"string\">' '</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-1-Dijkstra算法：O-n-2\"><a href=\"#3-1-Dijkstra算法：O-n-2\" class=\"headerlink\" title=\"3.1 Dijkstra算法：O(n^2)\"></a>3.1 Dijkstra算法：O(n^2)</h2><p>实现过程：1.找到未确定最短路径的点中目前距离最小的点，可以确定这个点的最短路径就是这个距离。<br>2.标记这个点，并用这个点去扩展其他点的最短路径。</p>\n<p>但为什么步骤一是正确的呢？</p>\n<p>因为找到的这个点的距离是由所有确定最短路径的点扩展而来的，如果它不是最短路径，那这个最短路径一定是由未确定的点扩展而来的，但其他的点只能绕一圈扩展到这个点，一定比当前距离长，由此得证。</p>\n<p>以上思想是此算法的灵魂，在最短路径的变式中，必须满足以上的贪心法则，才可以运用此算法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,d[<span class=\"number\">10010</span>],vh[<span class=\"number\">10010</span>];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> e,w;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt;node&gt; g[<span class=\"number\">10010</span>];<span class=\"comment\">//用vector实现，防止爆空间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\td[i]=<span class=\"number\">2147483647</span>;</span><br><span class=\"line\">\td[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> f,e,w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span>&gt;&gt;f&gt;&gt;e&gt;&gt;w;</span><br><span class=\"line\">\t\tnode q;</span><br><span class=\"line\">\t\tq.e=e;</span><br><span class=\"line\">\t\tq.w=w;</span><br><span class=\"line\">\t\tg[f].push_back(q);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> minn=<span class=\"number\">1e9</span>,minid=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;<span class=\"comment\">//找没有被标记的点的最小值</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!vh[j]&amp;&amp;d[j]&lt;minn)&#123;</span><br><span class=\"line\">\t\t\t\tminn=d[j];</span><br><span class=\"line\">\t\t\t\tminid=j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tvh[minid]=<span class=\"number\">1</span>;<span class=\"comment\">//此点确定最短路径</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> t=g[minid].size();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;t;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!vh[g[minid][j].e]&amp;&amp;d[minid]&lt;d[g[minid][j].e]-g[minid][j].w)</span><br><span class=\"line\">\t\t\t\td[g[minid][j].e]=d[minid]+g[minid][j].w;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;d[i]&lt;&lt;<span class=\"string\">' '</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2-Dijkstra算法的优先队列优化-O-n-m-log-m\"><a href=\"#3-2-Dijkstra算法的优先队列优化-O-n-m-log-m\" class=\"headerlink\" title=\"3.2 Dijkstra算法的优先队列优化:O((n+m)*log m)\"></a>3.2 Dijkstra算法的优先队列优化:O((n+m)*log m)</h2><p>由于以上算法每次都要找最小值，顺序查找复杂度为O(n^2)，所以可以用堆优化为O（nlogn）<br>这里用stl中的优先队列实现</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,d[<span class=\"number\">100010</span>],vh[<span class=\"number\">100010</span>];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> e,w;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node2</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> id,dis;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt; (node2 a,node2 b)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a.dis&gt;b.dis;<span class=\"comment\">//由于不清楚运算符重载在优先队列里的操作，符号一开始写反了</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">vector</span> &lt;node&gt; g[<span class=\"number\">100010</span>];</span><br><span class=\"line\">priority_queue &lt;node2&gt; que;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\td[i]=<span class=\"number\">2147483647</span>;</span><br><span class=\"line\">\td[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> f,e,w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span>&gt;&gt;f&gt;&gt;e&gt;&gt;w;</span><br><span class=\"line\">\t\tnode q;</span><br><span class=\"line\">\t\tq.e=e;</span><br><span class=\"line\">\t\tq.w=w;</span><br><span class=\"line\">\t\tg[f].push_back(q);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnode2 q;</span><br><span class=\"line\">\tq.dis=<span class=\"number\">0</span>;</span><br><span class=\"line\">\tq.id=s;</span><br><span class=\"line\">\tque.push(q);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(vh[que.top().id])que.pop();</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> head=que.top().id;</span><br><span class=\"line\">\t\tvh[head]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tque.pop();</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> t=g[head].size();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;t;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!vh[g[head][j].e]&amp;&amp;d[head]&lt;d[g[head][j].e]-g[head][j].w)&#123;</span><br><span class=\"line\">\t\t\t\td[g[head][j].e]=d[head]+g[head][j].w;</span><br><span class=\"line\">\t\t\t\tq.id=g[head][j].e;<span class=\"comment\">//入栈的id为这条边的终点序号，不是循环序号</span></span><br><span class=\"line\">\t\t\t\tq.dis=d[g[head][j].e];</span><br><span class=\"line\">\t\t\t\tque.push(q);</span><br><span class=\"line\">\t\t\t&#125;\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;d[i]&lt;&lt;<span class=\"string\">' '</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-Floyed算法：O-n-3\"><a href=\"#4-Floyed算法：O-n-3\" class=\"headerlink\" title=\"4.Floyed算法：O(n^3)\"></a>4.Floyed算法：O(n^3)</h2><p>此算法是基于dp思想的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> INF 2147483647</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n,m,s,d[<span class=\"number\">1010</span>][<span class=\"number\">1010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(i!=j)d[i][j]=INF;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> f,e,w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span>&gt;&gt;f&gt;&gt;e&gt;&gt;w;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(d[f][e]&gt;w)d[f][e]=w;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">1</span>;k&lt;=n;k++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span>&lt;&lt;d[s][i]&lt;&lt;<span class=\"string\">' '</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它还可以判断连通性，如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">1</span>;k&lt;=n;k++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">\t\t\t\tg[i][j]=g[i][j]||(g[i][k]&amp;&amp;g[k][j]);</span><br></pre></td></tr></table></figure>\n","slug":"最短路径","comments":true,"link":"","permalink":"http://yoursite.com/2020/01/20/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","excerpt":"","categories":[],"tags":[]},{"title":"最小生成树","date":"2020-01-18T04:46:26.721Z","path":"2020/01/18/最小生成树/","text":"1. Prim算法此算法与dijkstra算法非常相似。 贪心思想，每次在已生成的树和未生成的树之间选择轻边。无论选轻边和重边都不会在两个圈中形成环，不会对未生成的最小生成树的集合产生影响，所以选择轻边。 用minn数组表示此点与当前最小生成树相连的边权最小值，vh数组表示此点是否已在最小生成树里，每次找到轻边就标记，并修改与轻边相连的边。 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,g[5010][5010],vh[5010],ans,minn[5010];int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(g,1,sizeof(g)); memset(minn,1,sizeof(minn)); for(int i=1;i&lt;=m;i++)&#123; int x,y,w; cin&gt;&gt;x&gt;&gt;y&gt;&gt;w; if(w&lt;g[x][y])g[x][y]=w; if(w&lt;g[y][x])g[y][x]=w; &#125; minn[1]=0; for(int i=1;i&lt;=n;i++)&#123; int minid=0,minv=1e7; for(int j=1;j&lt;=n;j++) if(!vh[j]&amp;&amp;minn[j]&lt;minv)&#123; minv=minn[j]; minid=j; &#125; vh[minid]=1; ans+=minn[minid]; for(int j=1;j&lt;=n;j++) if(!vh[j]&amp;&amp;g[minid][j]&lt;minn[j]) minn[j]=g[minid][j]; &#125; bool flag=true; for(int i=1;i&lt;=n;i++) if(!vh[i])flag=false; if(flag)cout&lt;&lt;ans&lt;&lt;endl; else cout&lt;&lt;\"orz\\n\"; return 0;&#125; 2.Kruskal算法如果现在有几个连通块，要将它们连通，一定需要将它们之间最小的边连在一起。判断两点是否属于一个集合，可以用并查集操作。 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,father[5010],sum,ans;struct node&#123; int f,e,w;&#125;;node g[200010];bool cmp(node p,node q)&#123; return p.w&lt;q.w;&#125;int find(int k)&#123; if(father[k]==k)return k; return father[k]=find(father[k]);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) father[i]=i; for(int i=1;i&lt;=m;i++) cin&gt;&gt;g[i].f&gt;&gt;g[i].e&gt;&gt;g[i].w; sort(g+1,g+m+1,cmp); for(int i=1;i&lt;=m;i++)&#123; int mf=find(g[i].f),me=find(g[i].e); if(mf!=me)&#123; father[me]=mf; ans+=g[i].w; sum++; &#125; if(sum==n-1)break; &#125; if(sum==n-1)cout&lt;&lt;ans&lt;&lt;endl; else cout&lt;&lt;\"orz\\n\"; return 0;&#125;","raw":"---\n\ntitle: 最小生成树\ntag: 图论\n---\n\n## 1. Prim算法\n此算法与dijkstra算法非常相似。\n\n贪心思想，每次在已生成的树和未生成的树之间选择轻边。无论选轻边和重边都不会在两个圈中形成环，不会对未生成的最小生成树的集合产生影响，所以选择轻边。\n\n用minn数组表示此点与当前最小生成树相连的边权最小值，vh数组表示此点是否已在最小生成树里，每次找到轻边就标记，并修改与轻边相连的边。\n\n<!--more-->\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,g[5010][5010],vh[5010],ans,minn[5010];\nint main(){\n\tcin>>n>>m;\n\tmemset(g,1,sizeof(g));\n\tmemset(minn,1,sizeof(minn));\n\tfor(int i=1;i<=m;i++){\n\t\tint x,y,w;\n\t\tcin>>x>>y>>w;\n\t\tif(w<g[x][y])g[x][y]=w;\n\t\tif(w<g[y][x])g[y][x]=w;\n\t}\n\tminn[1]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint minid=0,minv=1e7;\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(!vh[j]&&minn[j]<minv){\n\t\t\t\tminv=minn[j];\n\t\t\t\tminid=j;\n\t\t\t}\n\t\tvh[minid]=1;\n\t\tans+=minn[minid];\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(!vh[j]&&g[minid][j]<minn[j])\n\t\t\t\tminn[j]=g[minid][j];\n\t}\n\tbool flag=true;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vh[i])flag=false;\n\tif(flag)cout<<ans<<endl;\n\telse cout<<\"orz\\n\";\n\treturn 0;\n} \n```\n## 2.Kruskal算法\n如果现在有几个连通块，要将它们连通，一定需要将它们之间最小的边连在一起。判断两点是否属于一个集合，可以用并查集操作。\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,father[5010],sum,ans;\nstruct node{\n\tint f,e,w;\n};\nnode g[200010];\nbool cmp(node p,node q){\n\treturn p.w<q.w;\n}\nint find(int k){\n\tif(father[k]==k)return k;\n\treturn father[k]=find(father[k]);\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++)\n\t\tfather[i]=i;\n\tfor(int i=1;i<=m;i++)\n\t\tcin>>g[i].f>>g[i].e>>g[i].w;\n\tsort(g+1,g+m+1,cmp);\n\tfor(int i=1;i<=m;i++){\n\t\tint mf=find(g[i].f),me=find(g[i].e);\n\t\tif(mf!=me){\n\t\t\tfather[me]=mf;\n\t\t\tans+=g[i].w;\n\t\t\tsum++;\n\t\t}\n\t\tif(sum==n-1)break;\n\t}\n\tif(sum==n-1)cout<<ans<<endl;\n\telse cout<<\"orz\\n\";\n\treturn 0;\n}\n```\n\n","content":"<h2 id=\"1-Prim算法\"><a href=\"#1-Prim算法\" class=\"headerlink\" title=\"1. Prim算法\"></a>1. Prim算法</h2><p>此算法与dijkstra算法非常相似。</p>\n<p>贪心思想，每次在已生成的树和未生成的树之间选择轻边。无论选轻边和重边都不会在两个圈中形成环，不会对未生成的最小生成树的集合产生影响，所以选择轻边。</p>\n<p>用minn数组表示此点与当前最小生成树相连的边权最小值，vh数组表示此点是否已在最小生成树里，每次找到轻边就标记，并修改与轻边相连的边。</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,g[<span class=\"number\">5010</span>][<span class=\"number\">5010</span>],vh[<span class=\"number\">5010</span>],ans,minn[<span class=\"number\">5010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(g,<span class=\"number\">1</span>,<span class=\"keyword\">sizeof</span>(g));</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(minn,<span class=\"number\">1</span>,<span class=\"keyword\">sizeof</span>(minn));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x,y,w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(w&lt;g[x][y])g[x][y]=w;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(w&lt;g[y][x])g[y][x]=w;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tminn[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> minid=<span class=\"number\">0</span>,minv=<span class=\"number\">1e7</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!vh[j]&amp;&amp;minn[j]&lt;minv)&#123;</span><br><span class=\"line\">\t\t\t\tminv=minn[j];</span><br><span class=\"line\">\t\t\t\tminid=j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tvh[minid]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tans+=minn[minid];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!vh[j]&amp;&amp;g[minid][j]&lt;minn[j])</span><br><span class=\"line\">\t\t\t\tminn[j]=g[minid][j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> flag=<span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!vh[i])flag=<span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(flag)<span class=\"built_in\">cout</span>&lt;&lt;ans&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"orz\\n\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-Kruskal算法\"><a href=\"#2-Kruskal算法\" class=\"headerlink\" title=\"2.Kruskal算法\"></a>2.Kruskal算法</h2><p>如果现在有几个连通块，要将它们连通，一定需要将它们之间最小的边连在一起。判断两点是否属于一个集合，可以用并查集操作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,father[<span class=\"number\">5010</span>],sum,ans;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> f,e,w;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">node g[<span class=\"number\">200010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(node p,node q)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p.w&lt;q.w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(father[k]==k)<span class=\"keyword\">return</span> k;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> father[k]=find(father[k]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t\tfather[i]=i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span>&gt;&gt;g[i].f&gt;&gt;g[i].e&gt;&gt;g[i].w;</span><br><span class=\"line\">\tsort(g+<span class=\"number\">1</span>,g+m+<span class=\"number\">1</span>,cmp);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mf=find(g[i].f),me=find(g[i].e);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(mf!=me)&#123;</span><br><span class=\"line\">\t\t\tfather[me]=mf;</span><br><span class=\"line\">\t\t\tans+=g[i].w;</span><br><span class=\"line\">\t\t\tsum++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(sum==n<span class=\"number\">-1</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(sum==n<span class=\"number\">-1</span>)<span class=\"built_in\">cout</span>&lt;&lt;ans&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"orz\\n\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","slug":"最小生成树","comments":true,"link":"","permalink":"http://yoursite.com/2020/01/18/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"1. Prim算法此算法与dijkstra算法非常相似。 贪心思想，每次在已生成的树和未生成的树之间选择轻边。无论选轻边和重边都不会在两个圈中形成环，不会对未生成的最小生成树的集合产生影响，所以选择轻边。 用minn数组表示此点与当前最小生成树相连的边权最小值，vh数组表示此点是否已在最小生成树里，每次找到轻边就标记，并修改与轻边相连的边。","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"}]}]}